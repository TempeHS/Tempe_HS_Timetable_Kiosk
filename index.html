<!DOCTYPE html>
<!--
Tempe High School Timetable Kiosk
Copyright (C) 2025 TempeHS

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
    <title id="page-title">Loading...</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; connect-src 'self' file:; img-src 'self' https://tempe-h.schools.nsw.gov.au data:;">
    <style id="dynamic-styles">
        /* Styles will be loaded dynamically from config */
    </style>
    <style>
        /* Base styles that don't depend on config */
    </style>
</head>
<body>
    <div id="header"></div>
    <div id="timetable"></div>
    <div id="current-time"></div>
    <script>
        // Global configuration object
        let CONFIG = null;
        
        // --- CONFIGURATION LOADING ---
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                CONFIG = await response.json();
                
                // Apply configuration to page
                applyConfiguration();
                
                return CONFIG;
            } catch (error) {
                console.error('Error loading configuration:', error);
                // Fall back to default Tempe HS configuration
                CONFIG = getDefaultConfig();
                applyConfiguration();
                return CONFIG;
            }
        }
        
        function getDefaultConfig() {
            // Default configuration for Tempe HS (fallback)
            return {
                "school": {
                    "name": "Tempe High School",
                    "logo": {
                        "url": "https://tempe-h.schools.nsw.gov.au/content/dam/doe/sws/schools/t/tempe-h/logo.png",
                        "opacity": 0.15,
                        "size": "auto 100vh"
                    }
                },
                "colors": {
                    "primary": "#AC0000",
                    "background": "#f7f8fc",
                    "overlay": "rgba(247, 248, 252, 0.3)",
                    "tile": {
                        "background": "#EDEDEE",
                        "border": "#555",
                        "shadow": "#b5b7b9",
                        "hover": "#EDEDEE"
                    },
                    "text": {
                        "primary": "#1a2325",
                        "secondary": "#b5b7b9",
                        "classCode": "#AC0000"
                    }
                },
                "schedule": {
                    "ignoredDays": [0, 6],
                    "schoolDays": [1, 2, 3, 4, 5],
                    "defaultShowMinutesBefore": 10,
                    "periods": {
                        "P0": {
                            "showFromDay": 5,
                            "showFromTime": "15:05",
                            "showUntilStart": true,
                            "description": "Period 0"
                        },
                        "P1": {
                            "showFromTime": "08:20",
                            "description": "Period 1"
                        }
                    }
                },
                "sportPeriods": {
                    "tuesday": {
                        "periods": ["P5", "P6"],
                        "yearGroups": {
                            "7": {
                                "label": "Year 7 & 8 Sport",
                                "includesYears": [7, 8],
                                "excludeYears": [8]
                            },
                            "9": {
                                "label": "Year 9 & 10 Sport", 
                                "includesYears": [9, 10],
                                "excludeYears": [10]
                            }
                        }
                    }
                },
                "yearGroups": {
                    "multiRowYears": [7, 9],
                    "displayYears": [7, 8, 9, 10, 11, 12],
                    "classCodePattern": "^(\\d+)"
                },
                "ui": {
                    "refreshInterval": 60000,
                    "cacheBusting": true
                },
                "files": {
                    "bellTimes": "bell_times.xml",
                    "lessons": "liss_info.xml",
                    "calendar": "calendar.xml"
                }
            };
        }
        
        function applyConfiguration() {
            if (!CONFIG) return;
            
            // Set page title
            document.getElementById('page-title').textContent = CONFIG.school.name;
            
            // Generate dynamic CSS
            const css = generateDynamicCSS();
            document.getElementById('dynamic-styles').innerHTML = css;
        }
        
        function generateDynamicCSS() {
            const c = CONFIG.colors;
            const logo = CONFIG.school.logo;
            
            return `
                body { 
                    font-family: Arial, sans-serif; 
                    background: ${c.background};
                    margin: 0;
                    position: relative;
                }
                body::before {
                    content: '';
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-image: url('${logo.url}');
                    background-repeat: no-repeat;
                    background-position: center center;
                    background-size: ${logo.size};
                    opacity: ${logo.opacity};
                    z-index: -1;
                    pointer-events: none;
                }
                body::after {
                    content: '';
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: ${c.overlay};
                    z-index: -1;
                    pointer-events: none;
                }
                h2 { text-align: center; font-size: 1.5rem }
                .year-section { margin: 20px 20px 20px 32px; }
                .year-label {
                    display: block;
                    font-weight: bold;
                    font-size: 1.25em;
                    margin-bottom: 10px;
                    text-align: left;
                    color: ${c.primary};
                    padding-left: 12px;
                }
                .tiles {
                    display: flex;
                    flex-direction: row;
                    flex-wrap: nowrap;
                    gap: 10px;
                    margin-bottom: 18px;
                    overflow-x: auto;
                }
                .tiles.multi-row {
                    flex-wrap: wrap;
                    overflow-x: visible;
                    max-height: none;
                }
                .tile {
                    background: ${c.tile.background};
                    border: 1px solid ${c.tile.border};
                    border-radius: 11px;
                    min-width: 100px;
                    max-width: 120px;
                    min-height: 56px;
                    padding: 7px 5px;
                    box-shadow: 2px 2px 6px ${c.tile.shadow};
                    display: flex;
                    flex-direction: column;
                    align-items: flex-start;
                    justify-content: center;
                    transition: box-shadow 0.2s;
                }
                .tile:hover {
                    box-shadow: 2px 6px 16px ${c.tile.hover};
                }
                .classcode { font-weight: bold; font-size: 1em; color: ${c.text.classCode}; margin-bottom: 2px; }
                .room { font-size: 0.95em; color: ${c.text.primary}; margin-bottom: 2px; }
                .teacher { font-size: 0.95em; color: ${c.text.primary}; }
                .empty-row {
                    color: ${c.text.secondary};
                    font-style: italic;
                    text-align: center;
                    padding: 14px 0;
                }
                #current-time {
                    text-align: right;
                    font-size: 0.9em;
                    color: ${c.text.primary};
                    margin: 20px 12px 10px 0;
                }
                #current-time.manual-override {
                    color: #d73502;
                    font-weight: bold;
                    background: #fff3cd;
                    padding: 5px 10px;
                    border-radius: 4px;
                    border: 1px solid #ffeaa7;
                }
                
                /* Responsive breakpoints - will be overridden by config if specified */
                @media (max-width: 1700px) {
                    .tiles { gap: 8px;}
                }
                @media (max-width: 1280px) {
                    .tiles { gap: 6px;}
                }
                @media (max-width: 700px) {
                    .year-section { max-width: 99vw; }
                    .tiles { gap: 4px;}
                    .tile { min-width: 90px; max-width: 100px;}
                }
                
                /* Responsive height breakpoint - compact layout for short screens */
                @media (max-height: ${CONFIG.ui.responsive.breakpoints.compactHeight}px) {
                    .year-section {
                        display: flex;
                        flex-direction: row;
                        align-items: flex-start;
                        gap: 10px;
                        margin: 20px 15px 20px 15px;
                    }
                    
                    .year-label {
                        flex-shrink: 0;
                        min-width: 80px;
                        max-width: 120px;
                        margin-bottom: 0;
                        margin-top: 8px;
                        writing-mode: horizontal-tb;
                        text-align: right;
                        padding-left: 0;
                        padding-right: 12px;
                    }
                    
                    .tiles {
                        flex: 1;
                        margin-bottom: 0;
                    }
                    
                    .tiles.multi-row {
                        max-height: 200px;
                        overflow-y: auto;
                        overflow-x: visible;
                    }
                }
                
                /* Original layout for tall screens */
                @media (min-height: ${CONFIG.ui.responsive.breakpoints.compactHeight + 1}px) {
                    .year-section {
                        display: block;
                        margin: 20px 20px 20px 32px;
                    }
                    
                    .year-label {
                        display: block;
                        margin-bottom: 10px;
                        writing-mode: horizontal-tb;
                        text-align: left;
                        padding-left: 12px;
                        padding-right: 0;
                    }
                    
                    .tiles {
                        margin-bottom: 18px;
                    }
                }
            `;
        }

        // --- MANUAL OVERRIDE FOR TESTING ---
        // 
        // INSTRUCTIONS FOR TESTING:
        // 1. Set USE_MANUAL_OVERRIDE to true
        // 2. Set MANUAL_DATE to the desired date (month is 0-indexed: 0=Jan, 1=Feb, etc.)
        // 3. Set MANUAL_TIME_HOURS (24-hour format: 0-23)
        // 4. Set MANUAL_TIME_MINUTES (0-59)
        // 5. Refresh the page to see the timetable for that date/time
        // 
        // EXAMPLES:
        // - Tuesday P5: new Date(2025, 7, 12), HOURS=13, MINUTES=25 (1:25 PM)
        // - Friday 3:05 PM: new Date(2025, 7, 15), HOURS=15, MINUTES=5
        // - Monday P0: new Date(2025, 7, 11), HOURS=7, MINUTES=45
        //
        const USE_MANUAL_OVERRIDE = false;
        
        // Manual date/time settings (only used when USE_MANUAL_OVERRIDE is true)
        const MANUAL_DATE = new Date(2025, 7, 12); // August 12, 2025 (month is 0-indexed)
        const MANUAL_TIME_HOURS = 8; // 1 PM
        const MANUAL_TIME_MINUTES = 20; // 25 minutes
        
        // Function to get current time (real or overridden)
        function getCurrentTime() {
            if (USE_MANUAL_OVERRIDE) {
                const manualDateTime = new Date(MANUAL_DATE);
                manualDateTime.setHours(MANUAL_TIME_HOURS, MANUAL_TIME_MINUTES, 0, 0);
                return manualDateTime;
            }
            return new Date();
        }
        
        // --- UTILS ---
        const pad2 = n => n < 10 ? '0' + n : n;
        const auDate = date => `${pad2(date.getDate())}/${pad2(date.getMonth() + 1)}/${date.getFullYear()}`;
        const longDay = date => date.toLocaleDateString('en-AU', { weekday: 'long' });

        // Given a date, return the next school day (skips ignored days from config)
        function getNextSchoolDay(date) {
            if (!CONFIG) return date;
            
            let nextDate = new Date(date);
            let dow = nextDate.getDay();
            
            // Keep incrementing until we find a school day
            while (CONFIG.schedule.ignoredDays.includes(dow)) {
                nextDate.setDate(nextDate.getDate() + 1);
                dow = nextDate.getDay();
            }
            
            // If we're already on a school day, move to the next school day
            if (CONFIG.schedule.schoolDays.includes(dow) && nextDate.toDateString() === date.toDateString()) {
                nextDate.setDate(nextDate.getDate() + 1);
                dow = nextDate.getDay();
                
                // Skip any ignored days again
                while (CONFIG.schedule.ignoredDays.includes(dow)) {
                    nextDate.setDate(nextDate.getDate() + 1);
                    dow = nextDate.getDay();
                }
            }
            
            return nextDate;
        }

        // --- XML LOADING ---
        function loadXML(path) {
            // Add cache busting timestamp if enabled in config
            let urlWithCacheBuster = path;
            if (CONFIG && CONFIG.ui.cacheBusting) {
                const cacheBuster = `?t=${Date.now()}`;
                urlWithCacheBuster = path + cacheBuster;
            }
            
            return fetch(urlWithCacheBuster)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(str => {
                    const parser = new window.DOMParser();
                    const xml = parser.parseFromString(str, "text/xml");
                    
                    // Check for XML parsing errors
                    const parseError = xml.getElementsByTagName("parsererror")[0];
                    if (parseError) {
                        throw new Error(`XML Parse Error: ${parseError.textContent}`);
                    }
                    
                    return xml;
                })
                .catch(error => {
                    console.error("Error loading XML:", error);
                    
                    // Provide helpful error message for CORS issues
                    if (error.message.includes('CORS') || error.message.includes('fetch')) {
                        throw new Error(`CORS Error: Cannot load local files. Please run this application using a local web server. See instructions below.`);
                    }
                    
                    throw error;
                });
        }

        // --- DATA PARSING ---
        // Helper function to extract member values from XML
        function extractMemberValue(members, memberName) {
            for(let j = 0; j < members.length; j++) {
                const member = members[j];
                const nameEl = member.getElementsByTagName("name")[0];
                const valueEl = member.getElementsByTagName("value")[0];
                
                if(nameEl && valueEl && nameEl.textContent === memberName) {
                    return valueEl.textContent;
                }
            }
            return null;
        }

        function parseBellTimes(xml) {
            const periods = [];
            const nodes = xml.getElementsByTagName("struct");
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const periodName = extractMemberValue(members, "Period");
                const startTime = extractMemberValue(members, "StartTime");
                const endTime = extractMemberValue(members, "EndTime");
                
                if(periodName && startTime && endTime) {
                    periods.push({
                        period: periodName,
                        start: parseTime(startTime),
                        end: parseTime(endTime)
                    });
                }
            }
            return periods;
        }
        function parseTime(timeStr) {
            if(!timeStr) return 0;
            const [hours, minutes] = timeStr.split(":").map(Number);
            return hours * 60 + minutes;
        }
        
        function parseCalendar(xml) {
            const calendar = [];
            const nodes = xml.getElementsByTagName("struct");
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const dateStr = extractMemberValue(members, "Date");
                const dayName = extractMemberValue(members, "DayName");
                const dayNumber = extractMemberValue(members, "DayNumber");
                
                if(dateStr && dayName && dayNumber) {
                    // Parse ISO date format: 20250811T00:00:00
                    const dateMatch = dateStr.match(/(\d{4})(\d{2})(\d{2})T/);
                    if(dateMatch) {
                        calendar.push({
                            date: new Date(dateMatch[1], dateMatch[2] - 1, dateMatch[3]),
                            dayName: dayName,
                            dayNumber: parseInt(dayNumber)
                        });
                    }
                }
            }
            return calendar;
        }

        function getDayNumber(calendarData, targetDate) {
            const entry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            return entry ? entry.dayNumber : null;
        }

        function parseLessons(xml, currentPeriod, calendarData, targetDate) {
            const lessonsByYear = {};
            const nodes = xml.getElementsByTagName("struct");
            
            // Get the day number for the current date from calendar
            const dayNumber = getDayNumber(calendarData, targetDate);
            
            // Check if this is a sport period based on config
            const isSportPeriod = isConfiguredSportPeriod(calendarData, targetDate, currentPeriod);
            
            for(let i = 0; i < nodes.length; i++) {
                const members = nodes[i].getElementsByTagName("member");
                
                const lessonDayNumber = parseInt(extractMemberValue(members, "DayNumber"));
                const period = extractMemberValue(members, "Period");
                const classCode = extractMemberValue(members, "ClassCode");
                const teacherCode = extractMemberValue(members, "TeacherCode");
                const roomCode = extractMemberValue(members, "RoomCode");
                
                // Only include lessons for the current day number AND current period
                if(classCode && period === currentPeriod && lessonDayNumber === dayNumber) {
                    // Extract year from class code using config pattern
                    const classMatch = classCode.match(new RegExp(CONFIG.yearGroups.classCodePattern));
                    if(classMatch) {
                        const year = classMatch[1];
                        
                        // Skip years excluded during sport periods
                        if(isSportPeriod && shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod)) {
                            continue;
                        }
                        
                        if (!lessonsByYear[year]) lessonsByYear[year] = [];
                        lessonsByYear[year].push({
                            ClassCode: classCode,
                            TeacherCode: teacherCode,
                            RoomCode: roomCode
                        });
                    }
                }
            }
            return lessonsByYear;
        }
        
        // Check if current period is configured as a sport period
        function isConfiguredSportPeriod(calendarData, targetDate, currentPeriod) {
            if (!CONFIG || !CONFIG.sportPeriods) return false;
            
            const calendarEntry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            if (!calendarEntry) return false;
            
            // Check each configured sport day
            for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                // Check if the calendar day name starts with the configured day key (e.g., 'TueB' starts with 'tue')
                if (calendarEntry.dayName.toLowerCase().startsWith(dayKey.toLowerCase().substring(0, 3)) && 
                    sportConfig.periods.includes(currentPeriod)) {
                    return true;
                }
            }
            
            return false;
        }
        
        // Check if a year should be excluded from sport periods
        function shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod) {
            if (!CONFIG || !CONFIG.sportPeriods) return false;
            
            const calendarEntry = calendarData.find(entry => {
                const entryDate = new Date(entry.date);
                return entryDate.toDateString() === targetDate.toDateString();
            });
            
            if (!calendarEntry) return false;
            
            // Check each configured sport day
            for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                if (calendarEntry.dayName.toLowerCase().startsWith(dayKey.toLowerCase().substring(0, 3)) && 
                    sportConfig.periods.includes(currentPeriod)) {
                    
                    // Check if this year should be excluded
                    for (const [groupYear, groupConfig] of Object.entries(sportConfig.yearGroups)) {
                        if (groupConfig.excludeYears && groupConfig.excludeYears.includes(parseInt(year))) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }

        // --- PERIOD LOGIC ---
        // Show periods based on configuration
        function getCurrentPeriodOrNext(bellTimes, now) {
            if (!CONFIG) return {period: "P0", date: now, forceNextDay: false};
            
            const currentMinutes = now.getHours()*60 + now.getMinutes();
            const currentDay = now.getDay();
            let period = null;
            let foundPeriod = false;
            
            // Skip ignored days from config
            if (CONFIG.schedule.ignoredDays.includes(currentDay)) {
                let nextSchoolDay = getNextSchoolDay(now);
                const firstPeriod = bellTimes.length ? bellTimes[0].period : "P0";
                return {period: firstPeriod, date: nextSchoolDay, forceNextDay: true};
            }
            
            // Sort bell times by start time to ensure proper order
            const sortedBellTimes = bellTimes.slice().sort((a, b) => a.start - b.start);
            
            for (let i = 0; i < sortedBellTimes.length; i++) {
                const p = sortedBellTimes[i];
                let showFromTime;
                
                // Check if this period has special configuration
                const periodConfig = CONFIG.schedule.periods[p.period];
                
                if (periodConfig) {
                    if (periodConfig.showFromDay !== undefined && periodConfig.showFromTime) {
                        // Special cross-day showing (like P0 showing from Friday)
                        if (currentDay === periodConfig.showFromDay) {
                            const [hours, minutes] = periodConfig.showFromTime.split(':').map(Number);
                            showFromTime = hours * 60 + minutes;
                            if (currentMinutes >= showFromTime) {
                                // Show next school day's period
                                let nextDate = getNextSchoolDay(now);
                                return {period: p.period, date: nextDate, forceNextDay: true};
                            }
                        } else if (periodConfig.showUntilStart && CONFIG.schedule.schoolDays.includes(currentDay)) {
                            // Show until the period starts on its actual day
                            if (currentMinutes < p.start) {
                                period = p.period;
                                foundPeriod = true;
                                break;
                            }
                        }
                    } else if (periodConfig.showFromTime) {
                        // Period shows from a specific time on the same day
                        const [hours, minutes] = periodConfig.showFromTime.split(':').map(Number);
                        showFromTime = hours * 60 + minutes;
                        if (currentMinutes >= showFromTime && currentMinutes < p.end) {
                            period = p.period;
                            foundPeriod = true;
                            break;
                        }
                    }
                } else {
                    // Default behavior: show period X minutes before start time
                    showFromTime = p.start - CONFIG.schedule.defaultShowMinutesBefore;
                    if (currentMinutes >= showFromTime && currentMinutes < p.end) {
                        period = p.period;
                        foundPeriod = true;
                        break;
                    }
                }
            }
            
            // If no current period found, determine what to show
            if (!foundPeriod) {
                // Find the last period end time
                const lastPeriodEnd = Math.max(...sortedBellTimes.map(p => p.end));
                
                if (currentMinutes >= lastPeriodEnd) {
                    // After last period: show first period for next school day
                    let nextDate = getNextSchoolDay(now);
                    const firstPeriod = sortedBellTimes.length ? sortedBellTimes[0].period : "P0";
                    return {period: firstPeriod, date: nextDate, forceNextDay: true};
                } else {
                    // Before any period starts: show first period
                    period = sortedBellTimes.length ? sortedBellTimes[0].period : "No Period";
                }
            }
            
            return {period, date: now, forceNextDay: false};
        }

        // Check if lessons contain any classes for configured display years
        function hasClassesForYears7to12(lessonsByYear) {
            if (!CONFIG || !CONFIG.yearGroups.displayYears) {
                return ['7', '8', '9', '10', '11', '12'].some(year => 
                    lessonsByYear[year] && lessonsByYear[year].length > 0
                );
            }
            
            return CONFIG.yearGroups.displayYears.some(year => 
                lessonsByYear[year.toString()] && lessonsByYear[year.toString()].length > 0
            );
        }

        // Get the next period in sequence
        function getNextPeriod(bellTimes, currentPeriod, currentDate) {
            const sortedBellTimes = bellTimes.slice().sort((a, b) => a.start - b.start);
            
            // Find current period index
            let currentIndex = sortedBellTimes.findIndex(p => p.period === currentPeriod);
            
            if (currentIndex === -1) {
                // Period not found, return first period of next day
                let nextDate = getNextSchoolDay(currentDate);
                return {
                    period: sortedBellTimes[0].period,
                    date: nextDate,
                    forceNextDay: true
                };
            }
            
            // Find the next period with a DIFFERENT name
            for (let i = currentIndex + 1; i < sortedBellTimes.length; i++) {
                if (sortedBellTimes[i].period !== currentPeriod) {
                    return {
                        period: sortedBellTimes[i].period,
                        date: currentDate,
                        forceNextDay: false
                    };
                }
            }
            
            // If we reach here, we're at the end or all remaining periods are the same
            // Go to next day's first period
            let nextDate = getNextSchoolDay(currentDate);
            return {
                period: sortedBellTimes[0].period,
                date: nextDate,
                forceNextDay: true
            };
        }

        // --- RENDER ---
        function renderHeader(period, dateObj, forceNextDay) {
            // Convert period to display name using config
            let periodLabel = period || "No Period";
            if (CONFIG && CONFIG.schedule.periods[period] && CONFIG.schedule.periods[period].description) {
                periodLabel = CONFIG.schedule.periods[period].description;
            } else if (period && period.match(/^P\d+$/)) {
                const periodNumber = period.substring(1); // Remove 'P' prefix
                periodLabel = `Period ${periodNumber}`;
            }
            
            const currentDay = dateObj.getDay();
            
            let datePrefix = "";
            if (forceNextDay) {
                // Use config to determine appropriate prefix
                if (CONFIG && CONFIG.schedule.ignoredDays.includes(currentDay - 1)) {
                    datePrefix = "Next: ";
                } else {
                    datePrefix = "Next: ";
                }
            }
            
            const dateLabel = datePrefix + longDay(dateObj) + " " + auDate(dateObj);
            
            document.getElementById('header').innerHTML = `<h2>${periodLabel} - ${dateLabel}</h2>`;
            
            // Update current time display
            const now = getCurrentTime();
            const currentTime = `${pad2(now.getHours())}:${pad2(now.getMinutes())}`;
            const timeLabel = USE_MANUAL_OVERRIDE ? `⚠️ MANUAL OVERRIDE: ${currentTime}` : `Current time: ${currentTime}`;
            
            const timeElement = document.getElementById('current-time');
            timeElement.innerHTML = timeLabel;
            timeElement.className = USE_MANUAL_OVERRIDE ? 'manual-override' : '';
        }
        
        function renderTimetable(lessonsByYear, currentPeriod, targetDate, calendarData) {
            if (!CONFIG) return;
            
            // Check if this is a sport period using config
            const isSportPeriod = isConfiguredSportPeriod(calendarData, targetDate, currentPeriod);
            
            let html = "";
            
            // Iterate through configured display years
            for (const yearNum of CONFIG.yearGroups.displayYears) {
                const year = yearNum.toString();
                
                if (!lessonsByYear[year]) continue;
                
                // Check if this year should be hidden during sport periods
                if (isSportPeriod && shouldExcludeYearFromSport(year, calendarData, targetDate, currentPeriod)) {
                    continue;
                }
                
                const isMultiRowYear = CONFIG.yearGroups.multiRowYears.includes(yearNum);
                const tilesClass = isMultiRowYear ? 'tiles multi-row' : 'tiles';
                
                // Determine the year label based on context
                let yearLabel = `Year ${year}`;
                
                if (isSportPeriod) {
                    // Check for sport period configurations
                    const calendarEntry = calendarData.find(entry => {
                        const entryDate = new Date(entry.date);
                        return entryDate.toDateString() === targetDate.toDateString();
                    });
                    
                    if (calendarEntry) {
                        for (const [dayKey, sportConfig] of Object.entries(CONFIG.sportPeriods)) {
                            if (calendarEntry.dayName.toLowerCase().includes(dayKey) && 
                                sportConfig.periods.includes(currentPeriod)) {
                                
                                // Check if this year has a special sport label
                                const sportGroup = sportConfig.yearGroups[year];
                                if (sportGroup && sportGroup.label) {
                                    yearLabel = sportGroup.label;
                                }
                            }
                        }
                    }
                }
                
                html += `<div class="year-section">
                    <span class="year-label">${yearLabel}</span>
                    <div class="${tilesClass}">`;
                    
                const lessons = lessonsByYear[year];
                if (lessons && lessons.length > 0) {
                    for (const lesson of lessons) {
                        html += `<div class="tile">
                            <div class="classcode">${(lesson.ClassCode||"").substring(0,7)}</div>
                            <div class="room">${lesson.RoomCode||""}</div>
                            <div class="teacher">${lesson.TeacherCode||""}</div>
                        </div>`;
                    }
                } else {
                    html += `<span class="empty-row">No classes</span>`;
                }
                html += `</div></div>`;
            }
            document.getElementById('timetable').innerHTML = html;
        }

        // --- MAIN ---
        let bellTimes = [];
        let lessonsXML = null;
        let calendarData = [];
        
        async function main() {
            // Load configuration first
            if (!CONFIG) {
                await loadConfig();
            }
            
            const now = getCurrentTime();

            if (bellTimes.length && lessonsXML && calendarData.length) {
                let periodObj = getCurrentPeriodOrNext(bellTimes, now);

                // Try to find a period with actual classes
                let lessonsByYear = parseLessons(lessonsXML, periodObj.period, calendarData, periodObj.date);
                let attempts = 0;
                const maxAttempts = bellTimes.length;
                
                // Check if current period has any classes for configured display years
                while (attempts < maxAttempts && !hasClassesForYears7to12(lessonsByYear)) {
                    // Get the next period
                    periodObj = getNextPeriod(bellTimes, periodObj.period, periodObj.date);
                    lessonsByYear = parseLessons(lessonsXML, periodObj.period, calendarData, periodObj.date);
                    attempts++;
                }
                
                renderHeader(periodObj.period, periodObj.date, periodObj.forceNextDay);
                renderTimetable(lessonsByYear, periodObj.period, periodObj.date, calendarData);
            } else {
                document.getElementById('header').innerHTML = "<h2>Loading data...</h2>";
                
                // Load configuration if not already loaded
                if (!CONFIG) {
                    await loadConfig();
                }
                
                // Get file paths from config
                const bellTimesFile = CONFIG.files.bellTimes;
                const lessonsFile = CONFIG.files.lessons;
                const calendarFile = CONFIG.files.calendar;
                
                // Load XML files
                Promise.all([
                    loadXML(bellTimesFile),
                    loadXML(lessonsFile),
                    loadXML(calendarFile)
                ]).then(([bellXML, lessonsXMLData, calendarXML]) => {
                    bellTimes = parseBellTimes(bellXML);
                    lessonsXML = lessonsXMLData;
                    calendarData = parseCalendar(calendarXML);
                    
                    if(bellTimes.length === 0) {
                        document.getElementById('header').innerHTML = "<h2>Error: No bell times found</h2>";
                        return;
                    }
                    
                    if(calendarData.length === 0) {
                        document.getElementById('header').innerHTML = "<h2>Error: No calendar data found</h2>";
                        return;
                    }
                    
                    main();
                }).catch(e=>{
                    console.error("Error loading data:", e);
                    
                    let errorMessage = "<h2>Error loading XML files</h2>";
                    let helpText = "";
                    
                    if (e.message.includes('CORS')) {
                        helpText = `
                            <div style="text-align: center; padding: 20px; color: #666; max-width: 600px; margin: 0 auto;">
                                <p><strong>CORS Policy Error:</strong> Modern browsers block local file access for security reasons.</p>
                                <p><strong>To run this application locally, you need to use a web server:</strong></p>
                                <div style="text-align: left; background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;">
                                    <p><strong>Option 1 - Python (if installed):</strong></p>
                                    <code>python -m http.server 8000</code><br>
                                    <small>Then open: http://localhost:8000</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 2 - Node.js (if installed):</strong></p>
                                    <code>npx http-server</code><br>
                                    <small>Then open the provided URL</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 3 - PHP (if installed):</strong></p>
                                    <code>php -S localhost:8000</code><br>
                                    <small>Then open: http://localhost:8000</small>
                                    
                                    <p style="margin-top: 15px;"><strong>Option 4 - VS Code Live Server:</strong></p>
                                    <small>Install "Live Server" extension and right-click index.html → "Open with Live Server"</small>
                                </div>
                                <p>Make sure config.json and XML files are in the same folder as index.html</p>
                            </div>`;
                    } else {
                        helpText = `
                            <div style="text-align: center; padding: 20px; color: #666;">
                                <p>Unable to load timetable data.</p>
                                <p>Please ensure config.json and XML files are in the same folder.</p>
                                <p>Error: ${e.message}</p>
                            </div>`;
                    }
                    
                    document.getElementById('header').innerHTML = errorMessage;
                    document.getElementById('timetable').innerHTML = helpText;
                });
            }
        }

        // ---- AUTO-RELOAD ----
        // Refresh page based on config interval
        function setupAutoReload() {
            if (CONFIG && CONFIG.ui.refreshInterval) {
                setInterval(() => location.replace(location.href), CONFIG.ui.refreshInterval);
            } else {
                // Default fallback
                setInterval(() => location.replace(location.href), 60000);
            }
        }

        // Initialize the application
        async function init() {
            await loadConfig();
            setupAutoReload();
            main();
        }

        init();
    </script>
</body>
</html>